# Azure Deployment Plan for climate-disaster-management Project

## **Goal**
Deploy a full-stack climate disaster management system to Azure using Azure Developer CLI (AZD) with Bicep infrastructure-as-code. The application consists of a React TypeScript frontend and Node.js Express backend with MongoDB database.

## **Project Information**

**Climate Disaster Management Platform**  
- **Frontend Stack**: React 18.3 + TypeScript + Vite + TailwindCSS
- **Backend Stack**: Node.js + Express 4.18 + MongoDB (Mongoose 8.0)
- **Type**: Emergency response platform with real-time alerts, AI assistant, hazard mapping, resource locator
- **Features**: 
  - Real-time disaster alerts with auto-refresh
  - Multi-language AI chatbot (6 languages including Telugu)
  - Interactive Mapbox GL hazard maps
  - Resource management and citizen reporting
  - Admin dashboard for emergency alerts
- **Containerization**: Dockerfiles to be generated
- **Dependencies**: 
  - MongoDB database (Cosmos DB for MongoDB API)
  - Mapbox GL API (client-side)
  - OpenRouter AI API (optional)
- **Hosting**: Azure Container Apps for both frontend and backend

## **Azure Resources Architecture**
> **Install the mermaid extension in IDE to view the architecture.**

```mermaid
graph TD
%% Services
svcazurecontainerapps_frontend["`Name: frontend
Path: /
Language: ts`"]
svcazurecontainerapps_backend["`Name: backend
Path: server
Language: js`"]
subgraph "Compute Resources"
%% Resources
subgraph containerappenv["Azure Container Apps (ACA) Environment"]
azurecontainerapps_frontend("`frontend (Azure Container App)`")
azurecontainerapps_backend("`backend (Azure Container App)`")
end
containerappenv:::cluster
end
subgraph "Dependency Resources"
%% Dependency Resources
azurecosmosdb_mongodb["`mongodb (Azure Cosmos DB for MongoDB)`"]
end
subgraph "Supporting Services"
acr["`Azure Container Registry`"]
insights["`Application Insights`"]
loganalytics["`Log Analytics Workspace`"]
identity["`User-Assigned Managed Identity`"]
keyvault["`Azure Key Vault`"]
end
%% Relationships
svcazurecontainerapps_frontend --> |"hosted on"| azurecontainerapps_frontend
azurecontainerapps_frontend -.-> |"http"| azurecontainerapps_backend
svcazurecontainerapps_backend --> |"hosted on"| azurecontainerapps_backend
azurecontainerapps_backend -.-> |"secret"| azurecosmosdb_mongodb
azurecontainerapps_frontend --> |"pulls image"| acr
azurecontainerapps_backend --> |"pulls image"| acr
azurecontainerapps_frontend --> |"logs to"| insights
azurecontainerapps_backend --> |"logs to"| insights
insights --> |"stores in"| loganalytics
azurecontainerapps_backend --> |"reads secrets"| keyvault
identity --> |"accesses"| keyvault
identity --> |"pulls from"| acr
```

**Architecture Relationships:**
- Frontend Container App serves the React SPA and communicates with Backend via HTTP
- Backend Container App handles API requests and connects to Cosmos DB for data persistence
- Both Container Apps pull their Docker images from Azure Container Registry
- User-Assigned Managed Identity has AcrPull permissions on the Container Registry
- Backend retrieves database connection string from Key Vault using Managed Identity
- Application Insights collects telemetry from both apps and stores logs in Log Analytics Workspace
- Container Apps Environment hosts both frontend and backend containers

## **Recommended Azure Resources**

### **Frontend Application (climate-disaster-management-frontend)**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with auto-scaling (0.25 vCPU, 0.5 GB memory minimum)
  - Performance: Scales from 0 to 30 replicas based on HTTP traffic
  - Suitable for web applications with variable traffic patterns
- **Configuration**:
  - Language: Node.js (for Vite build/serve)
  - Runtime: Nginx (to serve static React build)
  - Port: 80 (internal), exposed via HTTPS ingress
  - Environment Variables:
    - `VITE_API_URL`: Backend API endpoint URL
    - `NODE_ENV`: production
  - Docker Configuration:
    - dockerFilePath: `./Dockerfile`
    - dockerContext: `.`
    - Multi-stage build: Node build ‚Üí Nginx serve
- **Dependencies**: 
  - Backend Container App (HTTP connection)

### **Backend Application (climate-disaster-management-backend)**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with auto-scaling (0.5 vCPU, 1 GB memory minimum)
  - Performance: Scales from 1 to 30 replicas based on HTTP requests
  - Higher baseline resources for API processing and database operations
- **Configuration**:
  - Language: Node.js 20+
  - Runtime: Node.js with Express
  - Port: 3001 (internal)
  - Environment Variables:
    - `MONGODB_URI`: Connection string from Key Vault (secret reference)
    - `JWT_SECRET`: JWT signing secret from Key Vault
    - `PORT`: 3001
    - `NODE_ENV`: production
    - `OPENROUTER_API_KEY`: (optional) AI API key
    - `COHERE_API_KEY`: (optional) AI API key
  - Docker Configuration:
    - dockerFilePath: `./server/Dockerfile`
    - dockerContext: `./server`
- **Dependencies**: 
  - **Cosmos DB for MongoDB API**
    - **Name**: mongodb
    - **SKU**: Serverless (RU/s autoscaling)
      - Performance: Auto-scales based on usage, ideal for variable workloads
      - Recommended for disaster management with burst traffic during emergencies
    - **Service Type**: Azure Cosmos DB for MongoDB (API version 4.2+)
    - **Connection Type**: Connection String (stored in Key Vault, accessed via Managed Identity)
    - **Environment Variables**:
      - `MONGODB_URI`: `@Microsoft.KeyVault(SecretUri=https://{vault}.vault.azure.net/secrets/mongodb-connection-string/)`
    - **Configuration**:
      - Enable automatic failover across regions
      - Backup policy: Continuous (7-day retention)
      - Public network access: Disabled (private endpoint from Container Apps)

## **Recommended Supporting Services**

1. **Application Insights**
   - Purpose: Monitor application performance, track exceptions, analyze user behavior
   - Configuration: Auto-instrumentation for Node.js and client-side tracking
   - Retention: 90 days default

2. **User-Assigned Managed Identity**
   - Purpose: Secure authentication for Azure resource access without credentials
   - Permissions:
     - Key Vault Secrets User role on Key Vault
     - AcrPull role on Container Registry

3. **Log Analytics Workspace**
   - Purpose: Centralized logging for all Container Apps and Application Insights
   - Retention: 30 days
   - Configuration: Both frontend and backend send container logs here

4. **Azure Key Vault**
   - Purpose: Securely store database connection strings and JWT secrets
   - SKU: Standard
   - Secrets to store:
     - `mongodb-connection-string`: Cosmos DB connection string
     - `jwt-secret`: JWT signing secret (generated)
   - Access Policy: User-Assigned Managed Identity has Get/List permissions

5. **Azure Container Registry (ACR)**
   - Purpose: Store Docker images for frontend and backend
   - SKU: Basic (sufficient for development/testing, upgrade to Standard for production)
   - Configuration:
     - Admin user: Disabled (use Managed Identity)
     - Public network access: Enabled (or configure with private endpoint)

## **Recommended Security Configurations**

1. **User-Assigned Managed Identity Permissions**:
   - **Key Vault Access**: Key Vault Secrets User role (RBAC)
   - **Container Registry Access**: AcrPull role (7f951dda-4ed3-4680-a7ca-43fe172d538d)
   - Assigned to: Both frontend and backend Container Apps

2. **Network Security**:
   - Container Apps: Internal ingress for backend, external HTTPS ingress for frontend
   - Cosmos DB: Firewall enabled, allow access only from Container Apps Environment
   - Key Vault: Network restrictions to Container Apps subnet (optional)

3. **Secrets Management**:
   - All sensitive values stored in Key Vault
   - Container Apps reference secrets using Key Vault secret URIs
   - No secrets in environment variables or source code

4. **HTTPS & Authentication**:
   - Frontend: Custom domain with managed SSL certificate
   - Backend: Internal HTTPS communication
   - JWT-based authentication for API endpoints

## **Execution Steps**

> **Below are the steps for Copilot to follow; ask Copilot to update or execute this plan.**

### **1. Containerization**
- [ ] Analyze repository structure using `appmod-analyze-repository`
- [ ] Generate Dockerfile for frontend using `appmod-plan-generate-dockerfile`
  - Multi-stage: Build React app with Vite ‚Üí Serve with Nginx
  - Expected path: `./Dockerfile`
- [ ] Generate Dockerfile for backend using `appmod-plan-generate-dockerfile`
  - Node.js runtime with Express server
  - Expected path: `./server/Dockerfile`
- [ ] Output: Two Dockerfiles created

### **2. Create Azure Infrastructure Files for AZD**
1. **Provisioning Tool**: AZD
   - Expected files: `azure.yaml`, `infra/main.bicep`, `infra/main.parameters.json`

2. **Get Available Regions and SKUs**:
   - [ ] Get user's Azure subscription ID from AZ CLI default subscription
   - [ ] Call `appmod-get-available-region-sku` with resource types:
     - `Microsoft.App/containerApps`
     - `Microsoft.DocumentDB/databaseAccounts` (Cosmos DB)
     - `Microsoft.ContainerRegistry/registries`
     - `Microsoft.KeyVault/vaults`
     - `Microsoft.OperationalInsights/workspaces`
   - [ ] Select optimal region based on availability (prefer: East US 2, West US 2, Central India)

3. **Check for Existing Files**:
   - [ ] Existing file paths: Check if `azure.yaml`, `infra/main.bicep` exist
   - [ ] If files exist: Verify they match required Azure resources, update if needed
   - [ ] If files missing: Proceed to generation

4. **Generate Infrastructure Files**:
   - [ ] Call `appmod-get-iac-rules` with:
     - deploymentTool: `azd`
     - iacType: `bicep`
     - resourceTypes: `["containerapp", "azurecosmosdb", "azurecontainerregistry", "azurekeyvault"]`
   - [ ] Generate `azure.yaml` with frontend and backend services
   - [ ] Generate `infra/main.bicep` with all Azure resources
   - [ ] Generate `infra/main.parameters.json` with environment-specific values
   - [ ] Generate supporting Bicep modules in `infra/` directory

5. **Validate Generated Files**:
   - [ ] Call `get_errors` on generated Bicep files
   - [ ] Fix any validation errors and regenerate if needed
   - [ ] Ensure Bicep linting passes

### **3. Environment Setup for AZD**
1. **Install Prerequisites**:
   - [ ] Check if Azure CLI is installed: `az --version`
   - [ ] Install Azure CLI if missing: Download from https://aka.ms/installazurecliwindows
   - [ ] Check if AZD is installed: `azd version`
   - [ ] Install AZD if missing: `winget install microsoft.azd`

2. **Create AZD Environment**:
   - [ ] Generate environment name: `climate-disaster-{random-suffix}` (e.g., `climate-disaster-dev`)
   - [ ] Run: `azd env new climate-disaster-dev --no-prompt`
   - [ ] If environment exists, verify it matches requirements

3. **Set Environment Variables**:
   - [ ] Review `infra/main.bicep` and `infra/main.parameters.json` for required variables
   - [ ] Set subscription ID: `azd env set AZURE_SUBSCRIPTION_ID {subscriptionId}`
   - [ ] Set resource group: `azd env set AZURE_RESOURCE_GROUP rg-climate-disaster-dev`
   - [ ] Set location: `azd env set AZURE_LOCATION {selectedRegion}`
   - [ ] Set environment name: `azd env set AZURE_ENV_NAME climate-disaster-dev`
   - [ ] Optional: Set `OPENROUTER_API_KEY` and `COHERE_API_KEY` if available

4. **Configure Subscription**:
   - [ ] Use default subscription from AZ CLI: `az account show --query id -o tsv`
   - [ ] Login if needed: `az login`

5. **Create Resource Group**:
   - [ ] Check if Bicep uses resource group scope deployment
   - [ ] Create resource group: `az group create --name rg-climate-disaster-dev --location {region}`

### **4. Deployment**
1. **Dry Run Provisioning**:
   - [ ] Run: `azd provision --preview --no-prompt`
   - [ ] Review what-if output to confirm resources
   - [ ] Fix any errors in Bicep files and retry

2. **Deploy to Azure**:
   - [ ] Run: `azd up --no-prompt`
     - This builds Docker images
     - Pushes to Azure Container Registry
     - Provisions all infrastructure
     - Deploys containers to Azure Container Apps
   - [ ] Monitor deployment progress
   - [ ] If errors occur:
     - [ ] Review error logs
     - [ ] Fix configuration issues
     - [ ] Re-run `azd up --no-prompt`
     - [ ] Iterate until successful

3. **Deployment Validation**:
   - [ ] Call `appmod-get-azd-app-logs` to check application logs
   - [ ] Verify frontend is accessible via HTTPS URL
   - [ ] Test backend API endpoints
   - [ ] Confirm database connectivity
   - [ ] Check Application Insights for telemetry

### **5. Summarize Results**
1. **Generate Deployment Summary**:
   - [ ] Use `appmod-summarize-result` tool with:
     - deploymentStatus: success/failure
     - createdFileNames: List all generated files
     - deploymentRounds: Number of attempts
     - provisionedResourceTypes: All Azure resources created
   - [ ] Output file: `.azure/summary.copilotmd`

2. **Provide User with Access Information**:
   - [ ] Frontend URL: `https://{frontend-app-name}.{region}.azurecontainerapps.io`
   - [ ] Backend URL: `https://{backend-app-name}.{region}.azurecontainerapps.io`
   - [ ] Resource group: `rg-climate-disaster-dev`
   - [ ] Azure Portal link to resources

## **Progress Tracking**
- Copilot will create and update `.azure/progress.copilotmd` after each step
- Progress format:
  - ‚úÖ Completed tasks
  - üî≤ Pending tasks
  - ‚ùå Failed tasks with error notes
  
Example:
- [x] Containerization complete (Dockerfiles at ./Dockerfile and ./server/Dockerfile)
- [ ] Deployment in progress
  - Attempt 1 failed: Region quota exceeded
  - Fixed by selecting alternative region. Retrying...

## **Tools Checklist**
- [ ] appmod-analyze-repository
- [ ] appmod-plan-generate-dockerfile (called twice: frontend + backend)
- [ ] appmod-get-available-region-sku
- [ ] appmod-get-iac-rules
- [ ] appmod-get-azd-app-logs
- [ ] appmod-summarize-result

## **Post-Deployment Configuration**

After successful deployment, configure:

1. **Environment Variables in Azure Portal**:
   - Add `VITE_API_URL` to frontend Container App pointing to backend URL
   - Verify `MONGODB_URI` secret reference in backend
   - Add `MAPBOX_ACCESS_TOKEN` if using production Mapbox account

2. **Custom Domain** (Optional):
   - Configure custom domain for frontend in Container Apps
   - Add SSL certificate (managed or bring your own)

3. **Monitoring & Alerts**:
   - Set up Application Insights alerts for error rates
   - Configure alert for when container apps scale beyond thresholds
   - Enable Cosmos DB monitoring for RU consumption

4. **Continuous Deployment** (Optional):
   - Set up GitHub Actions workflow for CI/CD
   - Configure azd pipeline: `azd pipeline config`

## **Estimated Timeline**
- Repository analysis: 2-3 minutes
- Dockerfile generation: 3-5 minutes
- Infrastructure file creation: 5-8 minutes
- Azure provisioning: 8-12 minutes
- Container build & deploy: 10-15 minutes
- **Total**: Approximately 30-45 minutes for first deployment
